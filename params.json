{
  "name": "Php Multi Factor Authentication",
  "tagline": "Multi Factor authentication (mfa) for php.",
  "body": "\r\n## Php Multi Factor Web Authentication (MFA)\r\n\r\nOturum açma işlemlerinde kullancıyı yetkilendirme işlemleri birden fazla aşama ile yapılıyorsa bu çoklu yetkilendirme olarak adlandırılır. Multi-Factor Authentication güvenlik yöntemi; katmanlı bir yapıdan oluşur. Birden fazla kimlik doğrulama metoduyla saldırganların geçemeyeceği bir güvenlik kalkanı oluşturur. Bu metotlar aşağıdaki gibi olabilir : \r\n\r\n* OTP\r\n* QR Code\r\n* Çağrı\r\n* Sms\r\n\r\nMFA yani çoklu yetkilendirme yönteminde standart oturum açma işlevinden farklı olarak 2. aşamada kullanıcıdan  ile kimliğini doğrulaması istenir. Bir saldırgan yukarıda saydığımız kimlik doğrulama metotlarından kullanıcı parolasına sahip olsa bile MFA için yetkilendirilmiş güvenilir bir cihaza sahip olmadığından kimlik doğrulamayı geçemeyecektir. \r\n\r\n## Auth-MFA \r\n\r\nAuth-MFA yani çoklu yetkilendirme paketi yetki adaptörleri ile birlikte çeşitli ortak senaryolar yazılmış ölçeklenebilir bir yetkilendirme arayüzüdür ve tekil yetkilendirmeyi de destekler. Auth-MFA paketi Redis veya Memcached benzeri sürücüler sayesinde belleklenen kimlikleri oturum numaralarına göre yönetilebilmeyi sağlar.\r\n\r\n\r\n### Composer İle Yükleme\r\n\r\n```\r\ncomposer require obullo/auth-mfa\r\n```\r\n\r\n### Özellikler\r\n\r\n* Önbelleklenebilir kimlikler\r\n* Çoklu yetkilendirme\r\n* Farklı davranışlar için adaptörler\r\n* Farklı bilgisayarlardan oturum açan kullanıcıları görebilme ve oturumları sonlandırabilme\r\n* Farklı veritabanları için tablo sınıfları\r\n* Beni hatırla özelliği\r\n\r\n### Akış Şeması\r\n\r\nAşağıdaki akış şeması bir kullanıcının yetki doğrulama aşamalarından nasıl geçtiği ve servisin nasıl çalıştığı hakkında size bir ön bilgi verecektir:\r\n\r\n![Authentication](https://github.com/obullo/Auth-MFA/blob/master/flowchart.png?raw=true \"Authentication\")\r\n\r\nŞemada görüldüğü üzere <kbd>Guest</kbd> ve <kbd>User</kbd> olarak iki farklı durumu olan bir kullanıcı sözkonusudur. Guest <kbd>yetkilendirilmemiş</kbd> User ise servis tarafından <kbd>yetkilendirilmiş</kbd> kullanıcıdır.\r\n\r\nAkış şemasına göre Guest login butonuna bastığı anda ilk önce önbelleğe bir sorgu yapılır ve daha önceden kullanıcının önbellekte kalıcı bir kimliği olup olmadığında bakılır. Eğer hafıza bloğunda kalıcı yetki var ise kullanıcı kimliği buradan okunur yok ise veritabanına sorgu gönderilir ve elde edilen kimlik kartı tekrar önbelleğe yazılır.\r\n\r\n<a name=\"configuration\"></a>\r\n\r\n### Konfigürasyon\r\n\r\nAuthenticaiton sınıfı varsayılan olarak <a href=\"http://container.thephpleague.com/\" target=\"_blank\">Php League Container</a> paketi ile çalışır.\r\n\r\n```php\r\nrequire_once \"vendor/autoload.php\";\r\n\r\nsession_start();\r\n\r\n$container = new League\\Container\\Container;\r\n$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals();\r\n$container->share('request', $request);\r\n\r\n$container->addServiceProvider('ServiceProvider\\Redis');\r\n$container->addServiceProvider('ServiceProvider\\Database');\r\n$container->addServiceProvider('ServiceProvider\\Authentication');\r\n```\r\n\r\nTüm auth konfigürasyonu <kbd>classes/ServiceProvider/Authentication</kbd> sınıfı register metodu içerisinden düzenlenebilir.\r\n\r\n```php\r\n$container->share('Auth.PASSWORD_COST', 6);\r\n$container->share('Auth.PASSWORD_ALGORITHM', PASSWORD_BCRYPT);\r\n\r\n$container->share('Auth:Storage', 'Obullo\\Auth\\MFA\\Storage\\Redis')\r\n    ->withArgument($container->get('redis:default'))\r\n    ->withArgument($container->get('request'))\r\n    ->withMethodCall('setPermanentBlockLifetime', [3600]) // Should be same with app session lifetime.\r\n    ->withMethodCall('setTemporaryBlockLifetime', [300]);\r\n```\r\n\r\n<a name=\"adapters\"></a>\r\n\r\n### Adaptörler\r\n\r\nYetki doğrulama adaptörleri uygulamaya esneklik kazandıran sorgulama arabirimleridir, yetki doğrulamanın bir veritabanı ile mi yoksa farklı bir protokol üzerinden mi yapılacağını belirleyen sınıflardır. Varsayılan arabirim türü <kbd>Database</kbd> dir. ( RDBMS veya NoSQL türündeki veritabanları için ortak kullanılır ).\r\n\r\nFarklı adaptörlerin farklı seçenekler ve davranışları olması muhtemeldir , ama bazı temel şeyler kimlik doğrulama adaptörleri arasında ortaktır. Örneğin, kimlik doğrulama hizmeti sorgularını gerçekleştirmek ve sorgulardan dönen sonuçlar yetki doğrulama adaptörleri için ortak kullanılır.\r\n\r\n<a name=\"storages\"></a>\r\n\r\n### Hafıza Depoları\r\n\r\nHazıfa deposu yetki doğrulama esnasında kullanıcı kimliğini ön belleğe alır ve tekrar tekrar oturum açıldığında database ile bağlantı kurmayarak uygulamanın performans kaybetmesini önler. \r\n\r\nDesteklenen sürücüler\r\n\r\n* Redis\r\n* Memcached\r\n\r\nHafıza deposu servis konfigurasyonundan değiştirilebilir.\r\n\r\n```php\r\n$container->share('Auth:Storage', 'Obullo\\Auth\\MFA\\Storage\\Memcached')\r\n    ->withArgument($container->get('memcached:default'))\r\n```\r\n\r\nAyrıca anasayfadan servis sağlayıcınızı çağırmanız gerekir.\r\n\r\n```php\r\n$container->addServiceProvider('ServiceProvider\\Memcached');\r\n$container->addServiceProvider('ServiceProvider\\Database');\r\n$container->addServiceProvider('ServiceProvider\\Authentication');\r\n```\r\n\r\n### Database\r\n\r\nMysql benzeri ilişkili bir database kullanıyorsanız aşağıdaki sql kodunu çalıştırarak demo için bir tablo yaratın.\r\n\r\n```sql\r\nCREATE DATABASE IF NOT EXISTS test;\r\n\r\nuse test;\r\n\r\nCREATE TABLE IF NOT EXISTS `users` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(100) NOT NULL,\r\n  `password` varchar(80) NOT NULL,\r\n  `remember_token` varchar(64) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `username` (`username`),\r\n  KEY `remember_token` (`remember_token`)\r\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\r\n\r\nINSERT INTO `users` (`id`, `username`, `password`, `remember_token`) VALUES \r\n(1, 'user@example.com', '$2y$06$6k9aYbbOiVnqgvksFR4zXO.kNBTXFt3cl8xhvZLWj4Qi/IpkYXeP.', '');\r\n```\r\n\r\nTest kullanıcı adı <kbd>user@example.com</kbd> ve şifre <kbd>123456</kbd> dır.\r\n\r\n### Auth Table\r\n\r\nEğer mevcut database sorgularında değişiklik yapmak yada bir NoSQL çözümü kullanmak istiyorsanız Authentication servis sağlayıcısından Auth:Table anahtarındakı <kbd>Obullo\\MultiAuthAuth\\Adapter\\Database\\Table\\Db</kbd> değerini kendi tablo sınıfınız ile değiştirebilirsiniz.\r\n\r\n```php\r\n$container->share('Auth:Table', 'My\\Database\\Table\\Db')\r\n    ->withArgument($container->get('database:default'))\r\n    ->withMethodCall('setColumns', [array('username', 'password', 'email', 'remember_token')])\r\n    ->withMethodCall('setTableName', ['users'])\r\n    ->withMethodCall('setIdentityColumn', ['email'])\r\n    ->withMethodCall('setPasswordColumn', ['password'])\r\n    ->withMethodCall('setRememberTokenColumn', ['remember_token']);\r\n```\r\n\r\nMongo Db için örnek.\r\n\r\n```php\r\n$container->share('Auth:Table', 'Obullo\\Auth\\MFA\\Adapter\\Database\\Table\\Mongo');\r\n```\r\n\r\n### Oturum Açma\r\n\r\nOturum açma girişimi login metodu üzerinden gerçekleşir bu metot çalıştıktan sonra oturum açma sonuçlarını kontrol eden <kbd>AuthResult</kbd> nesnesi elde edilmiş olur.\r\n\r\n```php\r\n$authAdapter = new Obullo\\Auth\\MFA\\Adapter\\Database\\Database($container);\r\n$authAdapter->setRequest($request);\r\n$authAdapter->regenerateSessionId(true);\r\n\r\n$credentials = new Obullo\\Auth\\MFA\\Credentials;\r\n$credentials->setIdentityValue('user@example.com');\r\n$credentials->setPasswordValue('123456');\r\n$credentials->setRememberMeValue(false);\r\n\r\n$authResult = $authAdapter->authenticate($credentials);\r\n\r\nif (! $authResult->isValid()) {\r\n        \r\n    print_r($authResult->getMessages());\r\n\r\n} else {\r\n    header(\"Location: /example/Restricted.php\");\r\n}\r\n```\r\n\r\nOturum açma sonucunun doğruluğu <kbd>AuthResult->isValid()</kbd> metodu ile kontrol edilir eğer oturum açma denemesi başarısız ise dönen tüm hata mesajlarına getArray() metodu ile ulaşılabilir.\r\n\r\n```php\r\nif ($auhtResult->isValid()) {\r\n    \r\n    // Success\r\n\r\n} else {\r\n\r\n    // Fail\r\n\r\n    print_r($auhtResult->getArray());\r\n}\r\n```\r\n\r\n**Not:** <kbd>example</kbd> klasörü içerisinde oluşturulmuş örneğe göz atmayı unutmayın.\r\n\r\n<a name=\"login-error-results\"></a>\r\n\r\n### Hata Tablosu\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Kod</th>    \r\n            <th>Sabit</th>    \r\n            <th>Açıklama</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>0</td>\r\n            <td>AuthResult::FAILURE</td>\r\n            <td>Genel başarısız yetki doğrulama.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>-1</td>\r\n            <td>AuthResult::FAILURE_IDENTITY_AMBIGUOUS</td>\r\n            <td>Kimlik belirsiz olması nedeniyle başarısız yetki doğrulama.( Sorgu sonucunda 1 den fazla kimlik bulunduğunu gösterir ).</td>\r\n        </tr>\r\n        <tr>\r\n            <td>-2</td>\r\n            <td>AuthResult::FAILURE_CREDENTIAL_INVALID</td>\r\n            <td>Geçersiz kimlik bilgileri girildiğini gösterir.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td>AuthResult::SUCCESS</td>\r\n            <td>Yetki doğrulama başarılıdır.</td>\r\n        </tr>\r\n\r\n    </tbody>\r\n</table>\r\n\r\n<a name=\"identities\"></a>\r\n\r\n### Kimlikler\r\n\r\nKimlik sınıfı kullanıcı kimliğine ait <kbd>okuma</kbd> ve <kbd>yazma</kbd> işlemlerini yürütür. Kimliğe veri kaydetmek için set metodu,\r\n\r\n```php\r\n$identity->set('test', 'my_value');\r\n```\r\n\r\nKimlik bilgilerini elde etmek için ise get metodu kullanılır.\r\n\r\n\r\n```php\r\necho $identity->get('test');  // my_value\r\n```\r\n\r\nKimliğe ait tüm bilgileri almak için ise aşağıdaki metot kullanılır.\r\n\r\n```php\r\nprint_r($identity->getArray());\r\n\r\n/*\r\nArray\r\n(\r\n    [__isAuthenticated] => 1\r\n    [__isTemporary] => 0\r\n    [__rememberMe] => 0\r\n    [__time] => 1470858670.5284\r\n    [__ip] => 127.0.0.1\r\n    [__agent] => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0\r\n    [__lastActivity] => 1470419173\r\n    [id] => 1\r\n    [password] => $2y$10$0ICQkMUZBEAUMuyRYDlXe.PaOT4LGlbj6lUWXg6w3GCOMbZLzM7bm\r\n    [remember_token] => bqhiKfIWETlSRo7wB2UByb1Oyo2fpb86\r\n    [username] => user@example.com\r\n)\r\n*/\r\n```\r\n\r\n<a name=\"identity-keys\"></a>\r\n\r\n### Kimlik anahtarları\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Anahtar</th>    \r\n            <th>Açıklama</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>__isAuthenticated</td>\r\n            <td>Eğer kullanıcı yetkilendirilmiş ise bu anahtar <kbd>1</kbd> aksi durumda <kbd>0</kbd> değerini içerir.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__isTemporary</td>\r\n            <td>Yetki doğrulama onay özelliği için kullanılır.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__rememberMe</td>\r\n            <td>Kullanıcı giriş yaparken beni hatırla özelliğini kullandıysa bu değer <kbd>1</kbd> aksi durumda <kbd>0</kbd> değerini alır.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__time</td>\r\n            <td>Kimliğin ilk oluşturulma zamanıdır. Unix microtime() formatında kaydedilir.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__ip</td>\r\n            <td>Kullanıcının en son giriş yaptığı ip adresi.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__agent</td>\r\n            <td>Kullanıcının kullandığı tarayıcı ve işletim sistemi bilgisi.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__lastActivity</td>\r\n            <td>Kullanıcının en son aktivite zamanı.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n\r\n### Şifre Yenileme\r\n\r\nEğer login aşamasından sonra giriş başarısız ise <kbd>$authAdapter->passwordNeedsRehash()</kbd> metodu ile kullanıcının şifresinin yenilenip yenilenmeyeceğine karar verilir.Bu metot php <kbd>password_needs_rehash()</kbd> ve <kbd>password_hash()</kbd> metotlarını kullanarak yenilenen şifrenin hash değerine döner.\r\n\r\n```php\r\nif ($hash = $authAdapter->passwordNeedsRehash()) {\r\n    // UPDATE `users` WHERE email = `$email` SET password = \"$hash\";\r\n}\r\n```\r\n\r\nEğer metot false değerine dönmüyorsa kullanıcı şifresi dönen yeni hash değeri ile yenilenmelidir.\r\n\r\n### Adapter\r\n\r\n------\r\n\r\n#### $authAdapter->authenticate(Credentials $credentials);\r\n\r\nGirilen kullanıcı bilgileri ile yetki doğrulaması yaparak AuthResult nesnesine geri döner.\r\n\r\n#### $authAdapter->regenerateSessionId(true);\r\n\r\nKullanıcı giriş yaptıktan sonra oturum id sinin yeniden yaratılıp yaratılmayacağını belirler.\r\n\r\n#### $authAdapter->validateCredentials(Credentials $credentials);\r\n\r\nKullanıcıyı yetkilendirmeden kimlik bilgilerinin doğruluğunu kontrol eder. Doğru ise true aksi durumda false değerine geri döner.\r\n\r\n#### $authAdapter->authorizeUser(User $user);\r\n\r\nUser nesnesini kullanarak zaten kimlik bilgileri doğrulanmış Guest kullanıcıyı yetkilendirmek için kullanılır.\r\n\r\n<a name=\"identity-method-reference\"></a>\r\n\r\n### Identity\r\n\r\n------\r\n\r\n#### $identity->check();\r\n\r\nKullanıcı yetki doğrulamadan geçmiş ise <kbd>true</kbd> aksi durumda <kbd>false</kbd> değerine döner.\r\n\r\n#### $identity->guest();\r\n\r\nKullanıcının yetkisi doğrulanmamış kullanıcı, yani bir ziyaretçi olup olmadığını kontrol eder. Ziyaretçi ise <kbd>true</kbd> değilse <kbd>false</kbd> değerine döner.\r\n\r\n#### $identity->set($key, $value);\r\n\r\nKimlik dizisine girilen anahtara bir değer atar.\r\n\r\n#### $identity->get($key);\r\n\r\nKimlik dizisinden girilen anahtara ait değere geri döner. Anahtar yoksa false değerine döner.\r\n\r\n#### $identity->remove($key);\r\n\r\nKimlik dizisinden varolan anahtarı siler.\r\n\r\n#### $identity->expire($ttl);\r\n\r\nKullanıcı kimliğinin girilen süre göre geçtikten sonra yok olması için __expire anahtarı içerisine sona erme süresini kaydeder.\r\n\r\n#### $identity->isExpired();\r\n\r\nKimliğe expire() metodu ile kaydedilmiş süre sona erdiyse <kbd>true</kbd> aksi durumda <kbd>false</kbd> değerine döner. Bu method Http Auth katmanında aşağıdaki gibi kullanılabilir.\r\n\r\n```php\r\nif ($identity->isExpired()) {\r\n    $identity->destroy();    \r\n}\r\n```\r\n\r\n#### $identity->makeTemporary($expire = 300);\r\n\r\nBaşarılı giriş yapmış bir kullanıcı kimliğini çoklu yetkilendirme için belirlenen sona erme süresine göre geçici hale getirir. Süre sona erdiğinde kimlik hafıza deposundan silinir.\r\n\r\n#### $identity->makePermanent();\r\n\r\nÇoklu yetkilendirmeyi geçmiş bir kullanıcıya ait geçici kimliği kalıcı hale getirir. Kalıcı kimlik \r\nsüresi (varsayılan 3600 saniye) sona erdiğinde veritabanına tekrar sorgu yapılarak kimlik tekrar hafızaya kaydedilir.\r\n\r\n#### $identity->isTemporary();\r\n\r\nÇoklu yetkilendirmede kullanıcı kimliğinin geçici olup olmadığını gösterir, geçici ise <kbd>1</kbd> aksi durumda <kbd>0</kbd> değerine döner.\r\n\r\n#### $identity->updateTemporary(string $key, mixed $val);\r\n\r\nÇoklu yetkilendirmede geçici olarak oluşturulmuş kimlik bilgilerini güncellemenize olanak tanır.\r\n\r\n#### $identity->logout();\r\n\r\nÖnbellekteki <kbd>isAuthenticated</kbd> anahtarını <kbd>0</kbd> değeri ile güncelleyerek oturumu kapatır. Bu method önbellekteki kullanıcı kimliğini bütünü ile silmez sadece kullanıcıyı oturumu kapattı olarak kaydeder. Önbellekleme sayesinde <kbd>3600</kbd> saniye içerisinde kullanıcı bir daha sisteme giriş yaptığında <kbd>isAuthenticated</kbd> değeri <kbd>1</kbd> olarak güncellenir ve veritabanı sorgusunun önüne geçilmiş olur.\r\n\r\n#### $identity->destroy();\r\n\r\nÖnbellekteki kimliği bütünüyle yok eder.\r\n\r\n#### $identity->forgetMe();\r\n\r\nBeni hatırla çerezini kullanıcı tarayıcısından siler.\r\n\r\n#### $identity->refreshRememberToken();\r\n\r\nBeni hatırla çerezini yenileyerek veritabanı ve çereze tekrar kaydeder.\r\n\r\n#### $identity->getIdentifier();\r\n\r\nKullanıcın kimlik tanımlayıcısına geri döner. Tanımlayıcı genellikle <kbd>username</kbd> yada <kbd>email</kbd> değeridir.\r\n\r\n#### $identity->getPassword();\r\n\r\nKullanıcının hash edilmiş şifresine geri döner.\r\n\r\n#### $identity->getRememberMe();\r\n\r\nEğer kullanıcı beni hatırla özelliğini kullanıyorsa <kbd>1</kbd> değerine aksi durumda <kbd>0</kbd> değerine döner.\r\n\r\n#### $identity->getTime();\r\n\r\nKimliğin ilk yaratılma zamanını verir. ( Unix microtime ).\r\n\r\n#### $identity->getRememberMe();\r\n\r\nKullanıcı beni hatırla özelliğini kullandı ise <kbd>1</kbd> değerine, kullanmadı ise <kbd>0</kbd> değerine döner.\r\n\r\n#### $identity->getRememberToken();\r\n\r\nBeni hatırla çerezi değerine döner.\r\n\r\n#### $identity->getLoginId();\r\n\r\nBir veya birden fazla oturumlar numaralandırılır. Giriş yapmış kullanıcıya ait oturum numarasına aksi durumda false değerine döner.\r\n\r\n#### $identity->getArray()\r\n\r\nKullanıcının tüm kimlik değerlerine bir dizi içerisinde geri döner.\r\n\r\n\r\n### Storage\r\n\r\n------\r\n\r\n#### $storage->getUserSessions();\r\n\r\nKullanıcının bir yada birden fazla oturumu varsa bir dizi içerisinde bu oturumlara geri döner.\r\n\r\n```php\r\n$sessions = $storage->getUserSessions();\r\n```\r\n\r\nBir kullanıcının iki farklı tarayıcıdan oturum açtığını varsayarsak bu metot aşağıdaki gibi bir çıktı verir.\r\n\r\n```php\r\nprint_r($sesssion);\r\n\r\nArray\r\n(\r\n    [048f7b509a22800088f1cd8c1cc04b96] => Array\r\n        (\r\n            [__isAuthenticated] => 1\r\n            [__time] => 1470858670.5284\r\n            [__id] => user@example.com\r\n            [__key] => Auth:user@example.com:048f7b509a22800088f1cd8c1cc04b96\r\n            [__agent] => Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML,..\r\n            [__ip] => 212.124.16.1,\r\n            [__lastActivity] => 1470419674\r\n        )\r\n\r\n    [1dd468dbea32e8ed6f58cb00b40af76c] => Array\r\n        (\r\n            [__isAuthenticated] => 1\r\n            [__time] => 1470858670.6000\r\n            [__id] => user@example.com\r\n            [__key] => Auth:user@example.com:1dd468dbea32e8ed6f58cb00b40af76c\r\n            [__agent] => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0\r\n            [__ip] => 88.169.1.7,\r\n            [__lastActivity] => 1470419665\r\n        )\r\n);\r\n```\r\n\r\n#### $storage->killSession($loginID);\r\n\r\nOturum id değerine göre kullanıcın seçilen oturumunu sonlandırır.\r\n\r\n\r\n```php\r\n$storage->killSession(\"1dd468dbea32e8ed6f58cb00b40af76c\");\r\n```\r\n\r\nBir önceki örnekte Firefox tarayıcısına ait login ID değerini bu metoda gönderdiğimizde Firefox tarayıcısında açılmış bu oturum sonlandırılır.\r\n\r\n\r\n<a name=\"authResult-reference\"></a>\r\n\r\n### AuthResult\r\n\r\n------\r\n\r\n#### $authResult->isValid();\r\n\r\nLogin attempt methodundan geri dönen hata kodu <kbd>0</kbd> değerinden büyük ise <kbd>true</kbd> küçük ise <kbd>false</kbd> değerine döner. Başarılı oturum açma işlermlerinde hata kodu <kbd>1</kbd> değerine döner diğer durumlarda negatif değerlere döner.\r\n\r\n#### $authResult->getCode();\r\n\r\nLogin denemesinden sonra geçerli hata koduna geri döner.\r\n\r\n#### $authResult->getIdentifier();\r\n\r\nLogin denemesinden sonra geçerli kullanıcı kimliğine göre döner. ( id, username, email gibi. )\r\n\r\n#### $authResult->getMessages();\r\n\r\nLogin denemesinden sonra hata mesajlarına geri döner.\r\n\r\n#### $authResult->setCode(int $code);\r\n\r\nLogin denemesinden varsayılan sonuca hata kodu ekler.\r\n\r\n#### $authResult->setMessage(string $message);\r\n\r\nLogin denemesinden sonra sonuçlara bir hata mesajı ekler.\r\n\r\n#### $authResult->getArray();\r\n\r\nLogin denemesinden sonra tüm sonuçları bir dizi içerisinde verir.\r\n\r\n#### $authResult->getResultRow();\r\n\r\nLogin denemesinden sonra geçerli veritabanı adaptörü sorgu sonucuna yada varsa önbellekte oluşturulmuş sorgu sonucuna geri döner.\r\n\r\n### Çoklu Yetkilendirme\r\n\r\nÇoklu yetkilendirme kullanıcının kimliğini sisteme giriş yaptıktan hemen sonra <b>mobil uygulama</b>, <b>çağrı</b> veya <b>sms</b> gibi yöntemlerle onaylamasını sağlar.\r\n\r\nKullanıcı başarılı olarak giriş yaptıktan sonra kimliği kalıcı olarak ( varsayılan 3600 saniye ) önbelleklenir. Eğer kullanıcı onay adımından geçirilmek isteniyorsa kalıcı kimlikler <kbd>$identity->makeTemporary()</kbd> metodu ile geçici hale ( varsayılan 300 saniye ) getirilmelidir. Geçici olan bir kimlik 300 saniye içerisinde kendiliğinden yokolur.\r\n\r\nÇoklu yetkilendirmede kullanıcı sisteme giriş yaptıktan sonra,\r\n\r\n```php\r\n$identity->makeTemporary(300);\r\n```\r\n\r\nmetodu ile kimliği geçici hale getirilir ve kullanıcı sisteme giriş yapamaz. Kullanıcının geçici kimliğini onaylaması için ona bir doğrulama kodu gönderilmelidir.\r\n\r\n```php\r\nif ($authResult->isValid()) {\r\n    \r\n    $identity->makeTemporary();\r\n    \r\n    // Send verification code to user\r\n\r\n    header(\"Location: /example/Verify.php\");\r\n}\r\n```\r\n\r\nEğer kullanıcı verify sayfasında kimliğini onaylarsa geçici kimliğin <kbd>$identity->makePermanent()</kbd> metodu ile kalıcı hale getirilmesi gereklidir. Bir kimlik kalıcı yapıldığında kullanıcı sisteme başarılı bir şekilde giriş yapmış olur.\r\n\r\n\r\n```php\r\n$identity->makePermanent();\r\n```\r\n\r\nEğer çoklu yetkilendirme yani geçici kimlik oluşturma fonksiyonu kullanılmıyorsa, sistem her kimliği <kbd>kalıcı</kbd> olarak kaydeder.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}