{
  "name": "Php Web Authentication",
  "tagline": "Php authentication with rich features.",
  "body": "\r\n## Php Web Authentication\r\n\r\nObullo Auth package is designed to ease the management of authorization in the medium and large-scale applications caching the user identities according to their session numbers with the help of cache drivers. Auth package aims to be a scalable solution using the authentication adapters written for various common scenarios and supports multifactor authentication.\r\n\r\n### Installing with Composer\r\n\r\n```\r\ncomposer require obullo/auth\r\n```\r\n\r\n### Installing Demo Application\r\n\r\n```\r\ngit clone git@github.com:obullo/Auth-Demo.git auth-demo\r\n```\r\n\r\nTo look over the real examples try to install demo application.\r\n\r\n### Features\r\n\r\n* Cachable Identities\r\n* Multifactor Authentication (MFA)\r\n* Adapters for varied behaviors\r\n* Ability to see the users opening sessions with different computers and terminate the sessions\r\n* Table classes for different databases\r\n* 'Remember Me' feature\r\n\r\n### MFA Feature \r\n\r\nIn login operations, if authorizing the users includes more than one step, it is called multiple authorization. The method Multi-Factor Authentication consists of a multi-layered structure. It provides a shield which the attackers cannot get through with several authentication methods. These methods may be like below ones:\r\n\r\n* OTP\r\n* QR Code\r\n* Call\r\n* Sms\r\n\r\nMFA, multiple authorization method, has a second step which get users required to authenticate their identities unlike standard login functions. Even if an attacker has a user password, he cannot pass the authentication since he does not have a secure device authorized for MFA.  \r\n\r\n* This feature is optional.\r\n\r\n### Flow Chart\r\n\r\nThe below diagram will give you a prior knowledge about how a user pass the authorization verification steps and how the server works:\r\n\r\n![Authentication](https://github.com/obullo/mfa/blob/master/flowchart.png?raw=true \"Authentication\")\r\n\r\nAs seen on schema, two users are at the issue as <kbd>Guest</kbd> and <kbd>User</kbd>. Guest is <kbd>unauthorized</kbd> and user is <kbd>authorized</kbd> on the service side.\r\n\r\nAccording to the schema, as soon as the Guest clicks the login button, firstly the cache is queried and checked if the user has already had a permanent identity. If there are permanent authorization on the memory block, the user idendity is read from here. If not, the database is queried and retrieved identity card is  re-written into cache.\r\n\r\n<a name=\"configuration\"></a>\r\n\r\n### Configuration\r\n\r\nAuthentication class works with <a href=\"http://container.thephpleague.com/\" target=\"_blank\">Php League Container</a> package by default.\r\n\r\n```php\r\nrequire_once \"vendor/autoload.php\";\r\n\r\nsession_start();\r\n\r\n$container = new League\\Container\\Container;\r\n$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals();\r\n$container->share('request', $request);\r\n\r\n$container->addServiceProvider('ServiceProvider\\Redis');\r\n$container->addServiceProvider('ServiceProvider\\Database');\r\n$container->addServiceProvider('ServiceProvider\\Authentication');\r\n```\r\n\r\nAll the configuration of the auth can be edited in the register method in the <kbd>classes/ServiceProvider/Authentication</kbd> class.\r\n\r\n```php\r\n$container->share('Auth.PASSWORD_COST', 6);\r\n$container->share('Auth.PASSWORD_ALGORITHM', PASSWORD_BCRYPT);\r\n\r\n$container->share('Auth:Storage', 'Obullo\\Auth\\Storage\\Redis')\r\n    ->withArgument($container->get('redis:default'))\r\n    ->withArgument($container->get('request'))\r\n    ->withMethodCall('setPermanentBlockLifetime', [3600]) // Should be same with app session lifetime.\r\n    ->withMethodCall('setTemporaryBlockLifetime', [300]);\r\n```\r\n\r\n<a name=\"adapters\"></a>\r\n\r\n### Adapters\r\n\r\nIdentity verification adapters are interfaces adding flexibility to applications, which specify identity is verified with either a database or over a different protocol. The default interface is <kbd>Database</kbd> (It is used commonly for both RDBMS  and NoSQL  databases).  \r\n\r\nIt is possible that different adapters have different behaviors and options, however, some basic procedures are common among the identity verification adapters such as performing the queries for identity verification service and results returned by these queries. \r\n\r\n<a name=\"storages\"></a>\r\n\r\n### Storages\r\n\r\nStorage caches the user identity while verifying the identity and prevents the application from losing performance not connecting to the database when user logs in again and again.\r\n\r\nSupported Drivers\r\n\r\n* Redis\r\n* Memcached\r\n\r\nStorages can be changed in the service configuration.\r\n\r\n```php\r\n$container->share('Auth:Storage', 'Obullo\\Auth\\Storage\\Memcached')\r\n    ->withArgument($container->get('memcached:default'))\r\n```\r\n\r\nAlso, you need to call your service provider from the mainpage.\r\n\r\n\r\n```php\r\n$container->addServiceProvider('ServiceProvider\\Memcached');\r\n$container->addServiceProvider('ServiceProvider\\Database');\r\n$container->addServiceProvider('ServiceProvider\\Authentication');\r\n```\r\n\r\n### Database\r\n\r\nIf you use a relational database like MySQL, run the below SQL code to create a table.\r\n\r\n\r\n```sql\r\nCREATE DATABASE IF NOT EXISTS test;\r\n\r\nuse test;\r\n\r\nCREATE TABLE IF NOT EXISTS `users` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(100) NOT NULL,\r\n  `password` varchar(80) NOT NULL,\r\n  `remember_token` varchar(64) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `username` (`username`),\r\n  KEY `remember_token` (`remember_token`)\r\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8;\r\n\r\nINSERT INTO `users` (`id`, `username`, `password`, `remember_token`) VALUES \r\n(1, 'user@example.com', '$2y$06$6k9aYbbOiVnqgvksFR4zXO.kNBTXFt3cl8xhvZLWj4Qi/IpkYXeP.', '');\r\n```\r\n\r\nThe name of the test user is <kbd>user@example.com</kbd> and the password is <kbd>123456</kbd>.\r\n\r\n### Auth Table\r\n\r\nIf you want to change the queries or want to use a NoSQL solution, you can replace the value <kbd>Obullo\\Auth\\Adapter\\Table\\Db</kbd> of the key Auth:Table with your table class from the Authentication service provider.\r\n\r\n```php\r\n$container->share('Auth:Table', 'My\\Table\\Db')\r\n    ->withArgument($container->get('database:default'))\r\n    ->withMethodCall('setColumns', [array('username', 'password', 'email', 'remember_token')])\r\n    ->withMethodCall('setTableName', ['users'])\r\n    ->withMethodCall('setIdentityColumn', ['email'])\r\n    ->withMethodCall('setPasswordColumn', ['password'])\r\n    ->withMethodCall('setRememberTokenColumn', ['remember_token']);\r\n```\r\n\r\nAn example for Mongo Db.\r\n\r\n```php\r\n$container->share('Auth:Table', 'Obullo\\Auth\\Adapter\\Database\\Table\\Mongo');\r\n```\r\n\r\n### Login\r\n\r\nThe login operation is performed over the login method and this method returns an <kbd>AuthResult</kbd> object checking the results of the login.\r\n\r\n```php\r\n$credentials = new Obullo\\Auth\\Credentials;\r\n$credentials->setIdentityValue('user@example.com');\r\n$credentials->setPasswordValue('123456');\r\n$credentials->setRememberMeValue(false);\r\n\r\n$authAdapter = new Obullo\\Auth\\Adapter\\Table($container);\r\n$authResult  = $authAdapter->authenticate($credentials);\r\n$authAdapter->regenerateSessionId(true);\r\n\r\nif (false == $authResult->isValid()) {\r\n    print_r($authResult->getMessages());\r\n} else {\r\n    $user = new Obullo\\Auth\\User\\User($credentials);\r\n    $user->setResultRow($authResult->getResultRow());\r\n\r\n    $identity = $authAdapter->authorize($user); // Authorize user;\r\n\r\n    header(\"Location: /example/Restricted.php\");\r\n}\r\n```\r\n\r\nThe login success is checked with the method <kbd>AuthResult->isValid()</kbd> and if the login fails, all the returning error messages can be reached with the method getArray().\r\n\r\n\r\n```php\r\nif ($auhtResult->isValid()) {\r\n    \r\n    // Success\r\n\r\n} else {\r\n\r\n    // Fail\r\n\r\n    print_r($auhtResult->getArray());\r\n}\r\n```\r\n\r\n**Note:** Remember take a look at the example created in the <kbd>example</kbd> folder.\r\n\r\n<a name=\"login-error-results\"></a>\r\n\r\n### Error Table\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Code</th>    \r\n            <th>Constant</th>    \r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>0</td>\r\n            <td>AuthResult::FAILURE</td>\r\n            <td>Failed general authorization verification</td>\r\n        </tr>\r\n        <tr>\r\n            <td>-1</td>\r\n            <td>AuthResult::FAILURE_IDENTITY_AMBIGUOUS</td>\r\n            <td>Failed authorization verification due to indefinite identity(Shows that the query results includes more than one identity).</td>\r\n        </tr>\r\n        <tr>\r\n            <td>-2</td>\r\n            <td>AuthResult::FAILURE_CREDENTIAL_INVALID</td>\r\n            <td>Shows that invalid credentials are entered</td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td>AuthResult::SUCCESS</td>\r\n            <td>Successful authorization verification</td>\r\n        </tr>\r\n\r\n    </tbody>\r\n</table>\r\n\r\n<a name=\"identities\"></a>\r\n\r\n### Identities\r\n\r\nIdentity class executes <kbd>read</kbd> and <kbd>write</kbd> operations of the user identity. The set method is used to save a value to the identity:\r\n\r\n```php\r\n$identity->set('test', 'my_value');\r\n```\r\n\r\nThe get method is used to retrieve the value from the credentials: \r\n\r\n\r\n```php\r\necho $identity->get('test');  // my_value\r\n```\r\n\r\nThe below method is used to get all the credentials:\r\n\r\n```php\r\nprint_r($identity->getArray());\r\n\r\n/*\r\nArray\r\n(\r\n    [__isAuthenticated] => 1\r\n    [__isTemporary] => 0\r\n    [__rememberMe] => 0\r\n    [__time] => 1470858670.5284\r\n    [__ip] => 127.0.0.1\r\n    [__agent] => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0\r\n    [__lastActivity] => 1470419173\r\n    [id] => 1\r\n    [password] => $2y$10$0ICQkMUZBEAUMuyRYDlXe.PaOT4LGlbj6lUWXg6w3GCOMbZLzM7bm\r\n    [remember_token] => bqhiKfIWETlSRo7wB2UByb1Oyo2fpb86\r\n    [username] => user@example.com\r\n)\r\n*/\r\n```\r\n\r\n<a name=\"identity-keys\"></a>\r\n\r\n### Identity Keys\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>Key</th>    \r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>__isAuthenticated</td>\r\n            <td>If the user is authorized this key contains the value <kbd>1</kbd>, otherwise <kbd>0</kbd>.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__isTemporary</td>\r\n            <td>It is used for the feature of authorization verification.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__rememberMe</td>\r\n            <td>If the user has used this feature when login, this contains <kbd>1</kbd>, otherwise <kbd>0</kbd>.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__time</td>\r\n            <td>Time when the identity is created. It is saved in the format of Unix microtime().</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__ip</td>\r\n            <td>The IP address which the user logins lastly.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__agent</td>\r\n            <td>The browser and operation system information that the user has</td>\r\n        </tr>\r\n        <tr>\r\n            <td>__lastActivity</td>\r\n            <td>The time of the last activity.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n\r\n### Password Rehash\r\n\r\nIf login has failed, the password rehash is decided with the method  <kbd>$authAdapter->passwordNeedsRehash()</kbd>. This method returns the new hash value of the password using the <kbd>password_needs_rehash()</kbd> and <kbd>password_hash()</kbd> methods of php.\r\n\r\n```php\r\nif ($hash = $authAdapter->passwordNeedsRehash()) {\r\n    // UPDATE `users` WHERE email = `$email` SET password = \"$hash\";\r\n}\r\n```\r\n\r\nIf method does not return false, the user password should be replace in db with the returned hash.\r\n\r\n### Adapter\r\n\r\n------\r\n\r\n#### $authAdapter->authenticate(Credentials $credentials);\r\n\r\nReturns to the AuthResult object after verifying the authorization with the user information.\r\n\r\n#### $authAdapter->regenerateSessionId(true);\r\n\r\nSpecifies if the session id will be re-created or not after login.\r\n\r\n#### $authAdapter->validateCredentials(Credentials $credentials);\r\n\r\nVerifies the credentials without authorizing the user and returns true or false accordingly.\r\n\r\n#### $authAdapter->authorize(User $user);\r\n\r\nUsed to authorize guest user whose credentials has already been verified with user object.\r\n\r\n<a name=\"identity-method-reference\"></a>\r\n\r\n### Identity\r\n\r\n------\r\n\r\n#### $identity->check();\r\n\r\nReturns <kbd>true</kbd> if the user passes authorization verification, otherwise <kbd>false</kbd>.\r\n\r\n#### $identity->guest();\r\n\r\nChecks if the user is a guest, whose authorization has not been verified. If guest, returns <kbd>true</kbd>, otherwise <kbd>false</kbd>.\r\n\r\n#### $identity->set($key, $value);\r\n\r\nSets a value to the key entered to the idendity array.\r\n\r\n#### $identity->get($key);\r\n\r\nReturns the value of the key entered from the identity array. Returns fakse if no key is found.\r\n\r\n#### $identity->remove($key);\r\n\r\nRemoves the existent key from the idendity array.\r\n\r\n#### $identity->expire($ttl);\r\n\r\nSets the expiring time to the __expire key in order for user idendity to be expired when the time passes.  \r\n\r\n#### $identity->isExpired();\r\n\r\nReturns <kbd>true</kbd> if the time set by the method expire() is expired and returns <kbd>false</kbd> otherwise. This method can be used on the Http Auth Layer as below: \r\n\r\n```php\r\nif ($identity->isExpired()) {\r\n    $identity->destroy();    \r\n}\r\n```\r\n\r\n#### $identity->makeTemporary($expire = 300);\r\n\r\nMakes the user idendity which has logged in successfully temporary according to the time specified for the multifactor authentication. When expired, idendity is removed from the storage.\r\n\r\n#### $identity->makePermanent();\r\n\r\nMakes the temporary identity of the user who has passed the multifactor authentication permanent. When the permanent idendity time(3600 seconds by default) expires, the database is re-queried and the idendity saves into memory. \r\n\r\n#### $identity->isTemporary();\r\n\r\nShows either user idendity is temporary or permanent in multifactor authentication, returns <kbd>1</kbd> if temporary, otherwise <kbd>0</kbd>. \r\n\r\n#### $identity->updateTemporary(string $key, mixed $val);\r\n\r\nEnables to update the temporary credentials in multifactor authentication.\r\n\r\n#### $identity->logout();\r\n\r\nLogs out while updating the <kbd>isAuthenticated</kbd> key in the cache with <kbd>0</kbd>. This method does not completely removes the user idendity from the cache, it just saves the user as if he has ended the session. Thanks to caching, when the user logs in again within <kbd>3600</kbd> seconds, <kbd>isAuthenticated</kbd> value is updated to <kbd>1</kbd> and the database query is prevented.\r\n\r\n#### $identity->destroy();\r\n\r\nDestroys the user idendity completely.\r\n\r\n#### $identity->forgetMe();\r\n\r\nRemoves the cookie 'remember me' from the browser.\r\n\r\n#### $identity->refreshRememberToken();\r\n\r\nRefreshes the cookie 'rememeber me' and saves into database and cookie again.\r\n\r\n#### $identity->getIdentifier();\r\n\r\nReturns the identifier of the user. It is generally <kbd>username</kbd> or <kbd>email</kbd>.\r\n\r\n#### $identity->getPassword();\r\n\r\nReturns the hashed password of the user.\r\n\r\n#### $identity->getRememberMe();\r\n\r\nReturns <kbd>1</kbd> if the user uses the feature 'remember me', otherwise returns <kbd>0</kbd>.\r\n\r\n#### $identity->getTime();\r\n\r\nReturns the first creation time of the idendity (Unix microtime).\r\n\r\n#### $identity->getRememberMe();\r\n\r\nIf the user has used the feature 'remember me' results <kbd>1</kbd>, otherwise returns <kbd>0</kbd>.\r\n\r\n#### $identity->getRememberToken();\r\n\r\nReturns the value of the cookie 'rememeber me'.\r\n\r\n#### $identity->getLoginId();\r\n\r\nOne or more sessions are numbered and returns returns the session number of the user logged in, otherwise returns false.\r\n\r\n#### $identity->getArray()\r\n\r\nReturns all the credentials within an array.\r\n\r\n### Storage\r\n\r\n------\r\n\r\n#### $storage->getUserSessions();\r\n\r\nIf user has one or more sessions, returns these sessions within an array.\r\n\r\n```php\r\n$sessions = $storage->getUserSessions();\r\n```\r\n\r\nIf a user logs in with two different browsers, the output of this method is similar to below. \r\n\r\n```php\r\nprint_r($sesssion);\r\n\r\nArray\r\n(\r\n    [048f7b509a22800088f1cd8c1cc04b96] => Array\r\n        (\r\n            [__isAuthenticated] => 1\r\n            [__time] => 1470858670.5284\r\n            [__id] => user@example.com\r\n            [__key] => Auth:user@example.com:048f7b509a22800088f1cd8c1cc04b96\r\n            [__agent] => Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML,..\r\n            [__ip] => 212.124.16.1,\r\n            [__lastActivity] => 1470419674\r\n        )\r\n\r\n    [1dd468dbea32e8ed6f58cb00b40af76c] => Array\r\n        (\r\n            [__isAuthenticated] => 1\r\n            [__time] => 1470858670.6000\r\n            [__id] => user@example.com\r\n            [__key] => Auth:user@example.com:1dd468dbea32e8ed6f58cb00b40af76c\r\n            [__agent] => Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0\r\n            [__ip] => 88.169.1.7,\r\n            [__lastActivity] => 1470419665\r\n        )\r\n);\r\n```\r\n\r\n#### $storage->killSession($loginID);\r\n\r\nTerminates the user session according to session id.\r\n\r\n```php\r\n$storage->killSession(\"1dd468dbea32e8ed6f58cb00b40af76c\");\r\n```\r\n\r\nIn the previous example, when login ID belonging to Firefox browser value is sent to this method, the session on the Firefox browser is terminated.\r\n\r\n<a name=\"authResult-reference\"></a>\r\n\r\n### AuthResult\r\n\r\n------\r\n\r\n#### $authResult->isValid();\r\n\r\nReturns <kbd>true</kbd> if the error code returning from the method login attempt greater than <kbd>0</kbd>, otherwise <kbd>false</kbd>. Successfull login operations returns the error code <kbd>1</kbd> and the other situations returns negative values.\r\n\r\n#### $authResult->getCode();\r\n\r\nReturns the error code after login attempt.\r\n\r\n#### $authResult->getIdentifier();\r\n\r\nReturns the credentials like id, username, email after login attempt.\r\n\r\n#### $authResult->getMessages();\r\n\r\nReturns the error messages after the login attempt.\r\n\r\n#### $authResult->setCode(int $code);\r\n\r\nSets an error code to default result from the login attempt.\r\n\r\n#### $authResult->setMessage(string $message);\r\n\r\nSets error messages to results returning from the login attempt.\r\n\r\n#### $authResult->getArray();\r\n\r\nReturns all the results in an array from the login attempt.\r\n\r\n#### $authResult->getResultRow();\r\n\r\nReturns the valid database adapter after the login attempt  according to query result either from database or cache if it exists.  \r\n\r\n### Recall (Recaller)\r\n\r\nIf the user has already had a cookie 'remember me', the user can be authorized without entering the user information using the recaller function.\r\n\r\n```php\r\nif ($token = $identity->hasRecallerCookie()) {\r\n\r\n    $recaller = new Obullo\\Auth\\Recaller($container);\r\n    \r\n    if ($resultRowArray = $recaller->recallUser($token)) {\r\n\r\n        $credentials = new Obullo\\Auth\\User\\Credentials;\r\n        $credentials->setIdentityValue($resultRowArray['email']);\r\n        $credentials->setPasswordValue($resultRowArray['password']);\r\n        $credentials->setRememberMeValue(true);\r\n\r\n        $user = new Obullo\\Auth\\User\\User($credentials);\r\n        $user->setResultRow($resultRowArray);\r\n\r\n        $authAdapter = new Obullo\\Auth\\Adapter\\Table($container);\r\n        $authAdapter->authorize($user);\r\n        $authAdapter->regenerateSessionId(true);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### Multifactor Authentication\r\n\r\nMultifactor authentication makes the identity confirmation easier with the methods <b>OTP</b>, <b>Çağrı</b>, <b>Sms</b> or <b>QRCode</b> after a user logs in.\r\n\r\nAfter a successful login, the user identity is cached permanently(3600 seconds by default). If the user is wanted to be approved,  permanent identities must be become temporary with the method <kbd>$identity->makeTemporary()</kbd> (300 seconds by default). A temporary idendity expires within 300 seconds itself. \r\n\r\nIn multifactor authentication, after user logs in,\r\n\r\n```php\r\n$identity->makeTemporary(300);\r\n```\r\n\r\nusing the method above, user idendity is made temporary and user cannot log in. The user must be sent verification code to approve his temporary idendity.\r\n\r\n```php\r\nif ($authResult->isValid()) {\r\n    \r\n    $identity->makeTemporary();\r\n    \r\n    // Send verification code to user\r\n\r\n    header(\"Location: /example/Verify.php\");\r\n}\r\n```\r\n\r\nIf verified, the temporary idendity must be set as permanent with the method <kbd>$identity->makePermanent()</kbd>. A permanent idendity means the user has successfully logged in.\r\n\r\n```php\r\n$identity->makePermanent();\r\n```\r\n\r\nIf multifactor authentication is not used, system saves all identities as <kbd>permanent</kbd>.\r\n\r\n\r\n### Mongo Table Driver\r\n\r\nIf you want to use Mongo table driver, add the Mongo service provider from the commong file. Remember updating the connection information in the service provider.\r\n\r\n```php\r\n// $container->addServiceProvider('ServiceProvider\\Database');\r\n$container->addServiceProvider('ServiceProvider\\Mongo');\r\n```\r\n\r\nSend the first argument in the authentication service as below.\r\n\r\n```php\r\n$this->container->get('mongo:default')->selectDB('test');\r\n```\r\n\r\nThe part needing to be changed in the service provider should be like below.\r\n\r\n```php\r\n$container->share('Auth:Table', 'Obullo\\Auth\\Adapter\\Table\\Mongo')\r\n    ->withArgument($this->container->get('mongo:default')->selectDB('test'))\r\n    ->withMethodCall('setColumns', [array('username', 'password', 'email', 'remember_token')])\r\n    ->withMethodCall('setTableName', ['users'])\r\n    ->withMethodCall('setIdentityColumn', ['email'])\r\n    ->withMethodCall('setPasswordColumn', ['password'])\r\n    ->withMethodCall('setRememberTokenColumn', ['remember_token']);\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}